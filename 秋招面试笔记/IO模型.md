# IO模型

## 同步阻塞

又称为Blocking IO

特点:在于系统执行recvfrom的时候，数据被拷贝进内核缓冲区时需要阻塞等待，kernel拿到结果，拷贝数据回用户内存空间时又需要一个阻塞等待。

![BIO](https://segmentfault.com/img/bVm1c3)

> 所以Blocking IO的最大特点就是在IO执行的两个阶段都需要等待

## 同步非阻塞

又称为Non-Blocking IO

特点：用户进程发起read操作时，如果kernel数据没准备好，它不会block用户进程而是会返回一个error。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。

![NIO](https://segmentfault.com/img/bVm1c4)

>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。

## IO多路复用

![IO多路复用](https://segmentfault.com/img/bVm1c5)

### select

select会分配readfds，writefds,exceptfds（读，写，异常）三大块数组。数组上限是定义好的，一般监听的上限为1024。**select监视对象为所有socket，select函数调用后是一直阻塞的！**
然后select的执行流程大致是每次调用select函数后，进程会阻塞，在将数据拷贝到kernel后，等待直到有fd文件描述符就绪，或者超时，然后直接返回。但是返回的是数组，想要知道是哪个fd可用，**需要on时间的遍历。**

获取到了就绪的fd，才会调用recvfrom进行阻塞的数据传输。

### poll

poll相对于select不用的是：poll没有采用三个位图来表示三个fdsets，而是采用了一个pollfd的指针来代替。并且pollfd本身并没有最大数量限制。（但是最大数量过后性能会下降）

相同的点就是poll函数返回之后，需要轮询获得结果。

>从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。

### epoll

epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。

工作模式：LT和ET
> 主要区别
> 1.LT模式
LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。
>2.ET模式
ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。
然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)
ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

总结一下：

在select/poll中，进程只有在调用一定方法后，内核才会对监视的文件描述符进行扫描。而epoll是事先通过epoll_ctl()注册一个文件描述符，一旦基于某个文件描述符就绪时，内核就会调用类似于callback的回调方法，迅速激活这个文件描述符，然后当进程调用epoll_wait的时候便能得到通知。**（去除了遍历轮询的方法，而是通过监听回调的机制）**

epoll的优点主要在于：

1. 监听的fd数量不受限制，它所支持的fd上限是最大可以打开文件数目，一般远大于2048
2. IO效率不会随着监视fd的数量增长而降低，epoll不同于select/poll的轮询方式，而是通过监听回调的方法，只有就绪的fd才会执行回调函数。
