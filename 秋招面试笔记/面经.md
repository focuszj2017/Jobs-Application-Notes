# 面经

## 3.27远景能源

### 1.TCP报文的结构

 固定首部长度为20字节，可变部分0~40字节，各字段解释：

1. source port number：源端口，16bits，范围0~65525。
2. target port number：目的端口，16bits，范围同上。
3. sequence number：数据序号，32bits，TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。
4. acknoledgement number：确认号，32bits，期望收到对方的下一个报文段的数据的第一个字节的序号。
5. header length：数据偏移，4bits，单位为4字节，它指出报文数据距TCP 报头的起始处有多远(TCP报文头长度？)。
6. reserved：保留字段（图中，包含CWR，ECE），6bits，保留今后使用，目前置0处理。
7. URG：紧急比特，1bit，当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。
8. ACK：确认比特，1bit，只有当 ACK=1 时确认号字段才有效。当 ACK=0 时，确认号无效。
9. PSH：推送比特，1bit，接收方 TCP 收到推送比特置1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。
10. RST：复位比特，1bit，当 RST=1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
11. SYN：同步比特，1bit，同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文。
12. FIN：终止比特，1bit，用来释放一个连接。当FIN=1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。
13. window size：窗口大小，16bits，窗口字段用来控制对方发送的数据量，单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。
14. checksum：检验和，16bits，检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。
15. urgent pointer：紧急指针字段，16bits，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。
16. options：选项字段，长度可变。TCP 首部可以有多达40字节的可选信息，用于把附加信息传递给终点，或用来对齐其它选项。

### 2.SSL加密

+ HTTPS = HTTP + SSL

+ 两种加密方式：对称加密（DES和AES等）和非对称加密（RSA，DH，DSA）

+ 主要流程：

  第一步 ：客户端A开启一个新的浏览器访问客户端时，会先让A安装一个数字证书，这个证书主要包含的是CA机构的公钥。
  第二步：服务端B发来CA机构给自己的证书，通过CA公钥解密被CA私钥加密的hash1，然后再用B的证书里面的hash算法将信息生成一个hash2，通过比较两个hash，若相等，确认这个数字证书是服务端B的。
  由于非对称加密算法复杂度和计算量大，对称加密效率高，SSL就将这两种加密算法混合着用，这样安全和效率就都能保证了。其中具体的过程如下：

  第一步 客户端A给出 支持的SSL版本+一个随机数+自己支持的加密方式
  第二步 服务端B接收到这些信息后确认加密方式+自己的安全证书+一个随机数发给A
  第三步 客户端A确认数字证书有效性（验证方法上面已经说明），然后生成一个随机数，并将这个随机数用B的数字证书公钥加密后发送给A。
  第四步 服务端B使用自己的私钥解密这个随机数
  第五步 A和B通过第二步确定的加密方法将前三个随机数生成一个对话密钥 用来接下来的通信（个人感觉不需要三个随机数，只用最后一个就够了，这样做可能是为了更安全）
  于是A和B就用那个用对称加密的方式快速有效安全的通信了。

### 3.关系型数据库

+ 流行的关系型数据库：

  Oracle，Microsoft SQL Server，MySQL，PostgreSQL，DB2，
  Microsoft Access， SQLite，Teradata，MariaDB(MySQL的一个分支)，SAP

+ 非关系型数据库：Redis，MongoDB

### 4.第三范式

### 5.乐观锁悲观锁应用场景

- 乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。
- 悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。

**简而言之记得一句话：读取频繁使用乐观锁，写入频繁使用悲观锁。乐观锁不能解决脏读的问题。**

### 6.Tomcat和Netty

+ Netty和Tomcat最大的区别就在于通信协议，Tomcat是基于Http协议的，他的实质是一个基于http协议的web容器，但是Netty不一样，他能通过编程自定义各种协议，因为netty能够通过codec自己来编码/解码字节流，完成类似redis访问的功能，这就是netty和tomcat最大的不同。

+ 现在高并发分布式网站架构一般采用nginx（前端负载均衡）+ Netty/Tomcat（HTTP）

  Netty是基于Java NIO开发的，而Tomcat是Apache下的针对HTTP的服务器项目，前者更像一个中间件框架，后者更像一个工具

### 7.转账函数怎么写

### 8.有用过消息中间件吗

## 4.7字节飞书一面

### 1.Netty底层如何实现拆包机制

#### 拆包的原理

在没有 Netty 的情况下，用户如果自己需要拆包，基本原理就是不断从 TCP 缓冲区中读取数据，每次读取完都需要判断是否是一个完整的数据包

1. 如果当前读取的数据不足以拼接成一个完整的业务数据包，那就保留该数据，继续从 TCP 缓冲区中读取，直到得到一个完整的数据包。
2. 如果当前读到的数据加上已经读取的数据足够拼接成一个数据包，那就将已经读取的数据拼接上本次读取的数据，构成一个完整的业务数据包传递到业务逻辑，多余的数据仍然保留，以便和下次读到的数据尝试拼接。

如果我们自己实现拆包，这个过程将会非常麻烦，我们的每一种自定义协议，都需要自己实现，还需要考虑各种异常，而 Netty 自带的一些开箱即用的拆包器已经完全满足我们的需求了，下面我们来介绍一下 Netty 有哪些自带的拆包器。

#### Netty 自带的拆包器

+ **1. 固定长度的拆包器 FixedLengthFrameDecoder**

如果你的应用层协议非常简单，每个数据包的长度都是固定的，比如 100，那么只需要把这个拆包器加到 pipeline 中，Netty 会把一个个长度为 100 的数据包 (ByteBuf) 传递到下一个 channelHandler。

+ **2. 行拆包器 LineBasedFrameDecoder**

从字面意思来看，发送端发送数据包的时候，每个数据包之间以换行符作为分隔，接收端通过 LineBasedFrameDecoder 将粘过的 ByteBuf 拆分成一个个完整的应用层数据包。

+ **3. 分隔符拆包器 DelimiterBasedFrameDecoder**

DelimiterBasedFrameDecoder 是行拆包器的通用版本，只不过我们可以自定义分隔符。

+ **4. 基于长度域拆包器 LengthFieldBasedFrameDecoder**

最后一种拆包器是最通用的一种拆包器，只要你的自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包。由于上面三种拆包器比较简单，读者可以自行写出 demo，接下来，我们就结合我们小册的自定义协议，来学习一下如何使用基于长度域的拆包器来拆解我们的数据包。

### 2.Kryo效率为什么好

> **序列化的过程中主要有3个指标：**
>
> 1、对象序列化后的大小
>
> 一个对象会被序列化工具序列化为一串byte数组，这其中包含了对象的field值以及元数据信息，使其可以被反序列化回一个对象
>
> 2、序列化与反序列化的速度
>
> 一个对象被序列化成byte数组的时间取决于它生成/解析byte数组的方法
>
> 3、序列化工具本身的速度
>
> 序列化工具本身创建会有一定的消耗。
> **从序列化后的字节可以看出以下几点**：
>
> 1、Kryo序列化后比Hessian小很多。（kryo优于hessian）
>
> 2、由于Kryo没有将类field的描述信息序列化，所以Kryo需要以自己加载该类的filed。这意味着如果该类没有在kryo中注册，或者该类是第一次被kryo序列化时，kryo需要时间去加载该类（hessian优于kryo）
>
> 3、由于2的原因，如果该类已经被kryo加载过，那么kryo保存了其类的信息，就可以很快的将byte数组填入到类的field中,而hessian则需要解析序列化后的byte数组中的field信息，对于序列化过的类，kryo优于hessian。
>
> 4、hessian使用了固定长度存储int和long，而kryo则使用的变长，实际中，很大的数据不会经常出现。(kryo优于hessian)
>
> 5、hessian将序列化的字段长度写入来确定一段field的结束，而kryo对于String将其最后一位byte+x70用于标识结束（kryo优于hessian）

### 3.数据库对性别sex要不要建索引

> 只有2种取值的字段,建了索引数据库也不一定会用,只会白白增加索引维护的额外开销,因为索引也是需要存储的,所以插入和更新的写入操作,同时需要插入和更新你这个字段的索引的.
>
> 所以说,唯一性太差的字段不需要创建索引,即便用于where条件.
>
> 相关,建立联合索引时,也要考虑把重复率低而又用得多的列放在前面.
> 比如: key (attr_id, attr_value)
> 联合索引左匹配:单查 attr_id 也能使用索引,单查 attr_value 将无法利用该联合索引.

### 4.联合索引底层（最左匹配）

> **最左前缀匹配原则：**在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
>
> 要想理解联合索引的最左匹配原则，先来理解下索引的底层原理。索引的底层是一颗B+树，那么联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。

### 5.堆和栈为什么不能合并

> 因为结构化语言里函数（子程序）调用最方便的实现方式就是用栈，以至于现在绝大部分芯片都对栈提供芯片级的硬件支持，一条指令即可搞定栈的pop操作。栈的好处是：方便、快、有效避免内存碎片化。栈的问题是：不利于管理大内存（尤其在16位和32位时代）、数据的生命周期难于控制（栈内的有效数据通常是连续存储的，所以pop时后申请的内存必须早于先申请的内存失效），所以栈不利于动态地管理并且有效地利用宝贵的内存资源。于是我们有了堆

### 6.TCP唯一标识

> TCP/IP唯一性含除**地址**和**端口（源端口和目的端口）**外还有一个时间上的标记才可完全确立。
> 对TCP而言在三次握手时的SYN标志会使用上一个**ISN**值，这个值是使用32位计数器，由0-4294967295，每一次连接都会分配到一个ISN值，连接双方对这个值会记录共识，假如这个值不一，就说明了这个连接已超时或无效甚至是被人恶意攻击冒充连接。

### 7.Zookeeper集群

![image-20210408233735887](C:\Users\95845\AppData\Roaming\Typora\typora-user-images\image-20210408233735887.png)

### 8.限流熔断

常见的限流算法：固定窗口计数器算法、滑动窗口计数器算法、漏桶算法、令牌桶算法

### 9.浏览器输入 URL 发生了什么

主要包括以下几个基本步骤：

1. 浏览器的地址栏输入URL并按下回车。
2. 浏览器查找当前URL是否存在缓存，并比较缓存是否过期。
3. DNS解析URL对应的IP。
4. 根据IP建立TCP连接（三次握手）。
5. HTTP发起请求。
6. 服务器处理请求，浏览器接收HTTP响应。
7. 渲染页面，构建DOM树。
8. 关闭TCP连接（四次挥手）。

### 10.四次挥手TIME_WAIT中2MSL

RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。

因此2MSL实际值应为4分钟

## 4.12飞书二面

### 1.Java I/O模型（os）

### 2.10w个数据怎么排序

### 3.外排序

## 4.12腾讯一面

### 1.TCP如何实现可靠传输

### 2.epoll在netty中的使用

### 3.IP数据报的校验和相较于TCP（UDP）报文校验和有什么区别

> UDP首先提供了校验和的功能，（以太网等协议也提供了差错控制）**其原因是不能保证源和目的之间的所有链路都提供差错检测。**这就是说，也许这些链路中的一条可能使用没有差错检测的协议。此外，即使报文段经链路正确地传输，当报文段存储在某台路由器的内存中时，也可能引入比特差错。
> **在既无法确保链路可靠性，又无法确保内存中的差错检测的情况下。**UDP就必须在**端到端**的基础上在运输层提供差错检测。这是一个在系统设计中被称颂的**端到端原则**的例子

## 4.13携程二面

### 1.反射有什么好处

+ **获取Class对象的三种方式**

1. Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象多用于配置文件，将类名定义在配置文件中。读取文件，加载类，如JDBC等。
2. 类名.class：通过类名的属性class获取多用于参数的传递。
3. 对象.getClass()：getClass()方法在Object类中定义着。多用于对象的获取字节码的方式。

**反射好处：**

反射、泛型创建对象主要用于解耦

## 2.Zookeeper的选举机制

## 3.Zookeeper服务器间通信

## 4.19招行卡中心一面

### 1.InvocationalHandler底层

不知道

### 2.分布式CAP理论

## 4.22蚂蚁一面

### 1.RPC框架中两个服务会注册两次吗

涉及负载均衡知识。

![g](C:\Users\95845\AppData\Roaming\Typora\typora-user-images\image-20210422154232573.png)

### 2.操作系统如何管理TCP/IP

### 3.JDK动态代理和cglib动态代理

1、JDK动态代理具体实现原理：

通过实现InvocationHandler接口创建自己的调用处理器；
通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理；
通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型；
通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入；
JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力，Spring通过Java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。

2、CGLib动态代理：

利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。

> 我们了解到，“代理”的目的是构造一个和被代理的对象有同样行为的对象，一个对象的行为是在类中定义的，对象只是类的实例。所以构造代理，不一定非得通过持有、包装对象这一种方式。
>
> 通过“继承”可以继承父类所有的公开方法，然后可以重写这些方法，在重写时对这些方法增强，这就是cglib的思想。根据里氏代换原则（LSP），父类需要出现的地方，子类可以出现，所以cglib实现的代理也是可以被正常使用的。

3、两者对比：

JDK动态代理是面向接口的。
CGLib动态代理是通过字节码底层继承要代理类来实现，因此如果被代理类被final关键字所修饰，会失败

### 4.线程池中工作队列需要注意什么

不能使用无界队列，要设定合适的容量大小，不然会发生队列溢出，OOM

**任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。**

### 5.讲讲Selector类实现机制

### 6.Netty通信中如果服务器宕机是怎么做的

在client模块做的超时策略

![image-20210422155504248](C:\Users\95845\AppData\Roaming\Typora\typora-user-images\image-20210422155504248.png)

![image-20210422155119386](C:\Users\95845\AppData\Roaming\Typora\typora-user-images\image-20210422155119386.png)

### 7.Netty框架如何使用TCP/IP

Netty中的tcp/ip体现

客户端采用bootstrap.connect()方法异步进行连接

![image-20210422155817547](C:\Users\95845\AppData\Roaming\Typora\typora-user-images\image-20210422155817547.png)

## 4.22美团点评一面

### 1.Spring Bean对象的初始化

### 2.输入url后加载网页的过程

　　1、浏览器的地址栏输入URL并按下回车。

　　2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。

　　3、DNS解析URL对应的IP。

　　4、根据IP建立TCP连接（三次握手）。

　　5、HTTP发起请求。

　　6、服务器处理请求，浏览器接收HTTP响应。

　　7、渲染页面，构建DOM树。

　　8、关闭TCP连接（四次挥手）。

## 7.20 字节Data一面

### Collections类

#### ArrayList与LinkedList的插入效率

ArrayList插入效率要考虑插入索引位置，如果ArrayList为空则直接插末尾为O（1），否则根据索引i位置 复杂度：O（n-i）

LinkedList插入效率为O（1）

### LC23 合并K个升序链表

### JVM

1、方法区能不能垃圾回收

2、静态方法究竟是在方法区中还是字节码文件内？

3、静态成员变量创建的对象在堆中还是方法区？

### 单例模式

1、volatie的用处？（内存屏障性和防止指令重排）

2、方法上static的作用？（不用static的话创建不了实例，因为构造方法私有）

## 字节抖音社交

字节一面7.9
因为还要准备期末考试，所以字节的面试战线有点长

自我介绍
Http和Https区别
什么是线程安全问题？怎么解决？
乐观锁悲观锁介绍一下
AQS相关
线程争抢资源的能力是什么？（自己答AQS的CLH队列的时候给自己挖的坑=，=
链表查找时间复杂度？怎么优化？
跳表实现说一下？时空复杂度？
设计题：如何准备飞机上的面与饭的数量？（第一次见这种题，直接放飞自我QAQ
最后一道算法lc79. 单词搜索

字节二面7.13
自我介绍
OS学过吗？
线程和进程区别？为什么还要提出线程这个概念？线程共享了什么？协程呢？线程真的比进程节约资源吗？（一套组合拳把我问傻
LRU了解吗？说一下实现思路？（lc经典题了，说了个map+双向链表的实现
那这个map你能手写出来吗？（经过百度二面后我也是又恶补了hashmap的实现，刷了几道lc相关的题
hash冲突怎么处理？除了拉链法你还知道哪些？
并发resize怎么实现？这时候来了读写操作呢？说一下具体流程？（我说了concurrentHashMap的实现思路
concurrentHashMap你能实现出来吗？（我何德何能啊=，=
最后一道经典算法，lc25. K个一组翻转链表
这场面试发现了自己很多不足，收获很大！

字节三面7.16，已oc
这场项目问的比较多

自我介绍
项目中分布式事务是怎么实现的？
能详细说说seata和RocketMQ的事务消息是怎么实现的吗？
如何保证消息顺利投放到MQ中？投放前宕机了怎么办？
详细说一下你们项目中的秒杀业务流程？
项目中的限流是怎么做的？
限流算法了解哪些？
设计题：用令牌桶算法设计一个限流器？（经过面试官的引导好歹是写出来了=，=
最后一道算法：经典lc46. 全排列

## 京东一面

1、线程池八个参数

  核心线程数、最大线程数、最大存活时间、时间单位、工作队列、拒绝策略、线程工厂类

2、JVM如何加载Class文件，过程

  加载-验证-准备-解析-初始化
  加载：1.通过类的全限定类名来获取定义此类的二进制字节流 2.将这个字节流代表的静态数据结构转换成方法区运行的数据结构 3.在堆中生成一个Class对象，作为方法访问的入口。
  验证：包括文件格式验证、元数据验证、字节码验证、符号引用验证
  准备：分配内存+设置变量初始值（0或者null）
  解析：比如将常量池中的符号引用替换为直接引用
  初始化：初始化阶段就是执行类构造器< clint >()方法的过程

3、AQS底层

4、InnoDB的索引结构好处

## 7.30 米哈游一面

1、格斗等低延时动作，应该用tcp还是udp
  如果不能接受100ms左右的延时，考虑使用udp

2、Redis的事务

3、IO多路复用中，什么场景会使用select？

4、epoll两种工作模式LT和ET
  LT：水平触发，只要文件描述符还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作。

  ET：边缘触发，检测到有IO事件时，通过epoll_wait调用会得到有事件通知的文件描述符，对于每一个被通知的文件描述符，必须将该文件描述符一直读到空，让errno返回EAGAIN为止，否则下次的epoll_wait不会返回余下的数据，会丢掉事件。

  ET比LT更加高效，因为ET只通知一次，而LT会通知多次，LT可能会充斥大量不关心的就绪文件描述符。

5、MySQL的myisam和Innodb的区别，以及各自的应用场景

+ 事务：Innodb支持事务，可以使用commit和rollback
+ 并发：Innodb支持行级锁，MyISAM表级锁。
+ 外键：Innodb支持外键
+ 崩溃恢复：MyISAM崩溃后发生损坏的概率高于Innodb，并且恢复时间长。
+ 其他特性；MyISAM支持压缩表和空间数据索引。

6、TCP的拥塞控制机制以及Nagle算法
  答：Nagle就是小于MSS（1460bytes）的报文会存到下一次发送，然后默认200ms超时会自动发送。

7、Redis的多线程？Redis的事务？

8、RDB会阻塞主线程吗？如果AOF文件量很大该怎么办？

    1. RDB会阻塞主线程吗？
       1. SAVE命令会，BGSAVE命令会在后台运行，不会阻塞线程。

9、Redis读写性能高的原因

> 1. 基于Hash存储
> 2. Redis数据结构简单，有些数据结构是专门设计的
> 3. Reactor-IO多路复用模型

10、关于Linux

  10.1、查看整体状态操作？

  10.2、僵尸进程和孤儿进程的区别？kill的原理？

11、MySQL慢查询如何定位？

> 针对这个问题需要做的，首先是定位执行慢的SQL语句，其次分析该SQL语句。
>
> **定位慢查询**有两种方法：
>
>   1. 使用慢查询日志
>     2. 开启慢查询日志 set global slow_query_log = on;
>     3. 设置慢查询阈值(一般为1s) set global long_query_time = 1;
>     4. 确定慢查询日志路径
>     5. 确定慢查询日志的文件名
>   6. 通过show processlist
>
> 定位到慢查询SQL语句后，**使用Explain来进行分析**。

## 7.30 京东二面

1、设计题：10亿的url去重

## 8.4百度二面

1、RPC框架亮点

2、泛型 编译期工作原理

3、TCP大量TIME_WAIT原因，处理做法？

+ net.ipv4.tcp_syncookies = 1表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
+ net.ipv4.tcp_tw_reuse = 1表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
+ net.ipv4.tcp_tw_recycle = 1表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
+ net.ipv4.tcp_fin_timeout修改系統默认的TIMEOUT时间

4、Redis分布式锁

5、泛洪攻击原因？TCP分配的资源？

6、服务请求方多次请求同一个方法，怎么分辨不同的请求

## 8.4 米哈游二面

1、Redis事务（Watch）

2、Linux基本操作

3、公司业务项目的分库数，数据量？

4、Redis主从复制

5、MySQL慢查询如何定位

## 美团到家(from NiuKe  )

1. 面向过程和面向对象的区别
2. 什么时候适合使用面向对象，什么时候适合使用面向过程
3. 多态的底层原理，重载和重写在jvm的实现（只知道重写是方法表，重载不太清楚）
4. public和private是在运行时进行验证还是在编译时就进行验证。（不清楚）
5. 如果让你设计创建对象的底层实现，你会怎么实现？ （直接按照jvm内存结构来说）
6. jvm的内存结构？
7. jvm线程和操作系统线程之间的区别和联系（不清楚）
8. 进程的通信方式，讲到了共享内存
9. 紧接上面，共享内存的生命周期（不清楚）
10. socket可以TCP和UDP共用吗？（回答不可以，面试官让我回去再看看）
11. socket种accept()和TCP三次握手之间的前后顺序。
12. DNS和HTTP，在传输层使用那些协议。
13. 为什么DNS即使用TCP又使用UDP
14. HTTP默认端口号，可以有其他端口吗？进程可以共用多个端口号吗？
15. 复盘笔试题（全都忘了。。。。）
16. 数据库的隔离级别
17. 编程题 （判断链表有环，返沪环的起始节点，先写了快慢指针，又问了有其他方式吗？）
18. 聊天，拿了那些offer，如何看待加班，如何看待纯crud的加班，看了那些书？
19. 反问
20. object类的equals()方法和clone()方法是做什么的，以及应用场景，什么时候需要equals和hashcode保持一致
