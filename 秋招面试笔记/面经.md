# 面经

## 3.27远景能源

### 1.TCP报文的结构

 固定首部长度为20字节，可变部分0~40字节，各字段解释：

1. source port number：源端口，16bits，范围0~65525。
2. target port number：目的端口，16bits，范围同上。
3. sequence number：数据序号，32bits，TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。
4. acknoledgement number：确认号，32bits，期望收到对方的下一个报文段的数据的第一个字节的序号。
5. header length：数据偏移，4bits，单位为4字节，它指出报文数据距TCP 报头的起始处有多远(TCP报文头长度？)。
6. reserved：保留字段（图中，包含CWR，ECE），6bits，保留今后使用，目前置0处理。
7. URG：紧急比特，1bit，当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。
8. ACK：确认比特，1bit，只有当 ACK=1 时确认号字段才有效。当 ACK=0 时，确认号无效。
9. PSH：推送比特，1bit，接收方 TCP 收到推送比特置1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。
10. RST：复位比特，1bit，当 RST=1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
11. SYN：同步比特，1bit，同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文。
12. FIN：终止比特，1bit，用来释放一个连接。当FIN=1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。
13. window size：窗口大小，16bits，窗口字段用来控制对方发送的数据量，单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。
14. checksum：检验和，16bits，检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。
15. urgent pointer：紧急指针字段，16bits，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。
16. options：选项字段，长度可变。TCP 首部可以有多达40字节的可选信息，用于把附加信息传递给终点，或用来对齐其它选项。

### 2.SSL加密

+ HTTPS = HTTP + SSL

+ 两种加密方式：对称加密（DES和AES等）和非对称加密（RSA，DH，DSA）

+ 主要流程：

  第一步 ：客户端A开启一个新的浏览器访问客户端时，会先让A安装一个数字证书，这个证书主要包含的是CA机构的公钥。
  第二步：服务端B发来CA机构给自己的证书，通过CA公钥解密被CA私钥加密的hash1，然后再用B的证书里面的hash算法将信息生成一个hash2，通过比较两个hash，若相等，确认这个数字证书是服务端B的。
  由于非对称加密算法复杂度和计算量大，对称加密效率高，SSL就将这两种加密算法混合着用，这样安全和效率就都能保证了。其中具体的过程如下：

  第一步 客户端A给出 支持的SSL版本+一个随机数+自己支持的加密方式
  第二步 服务端B接收到这些信息后确认加密方式+自己的安全证书+一个随机数发给A
  第三步 客户端A确认数字证书有效性（验证方法上面已经说明），然后生成一个随机数，并将这个随机数用B的数字证书公钥加密后发送给A。
  第四步 服务端B使用自己的私钥解密这个随机数
  第五步 A和B通过第二步确定的加密方法将前三个随机数生成一个对话密钥 用来接下来的通信（个人感觉不需要三个随机数，只用最后一个就够了，这样做可能是为了更安全）
  于是A和B就用那个用对称加密的方式快速有效安全的通信了。

### 3.关系型数据库

+ 流行的关系型数据库：

  Oracle，Microsoft SQL Server，MySQL，PostgreSQL，DB2，
  Microsoft Access， SQLite，Teradata，MariaDB(MySQL的一个分支)，SAP

+ 非关系型数据库：Redis，MongoDB

### 4.第三范式

### 5.乐观锁悲观锁应用场景

- 乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。
- 悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。

**简而言之记得一句话：读取频繁使用乐观锁，写入频繁使用悲观锁。乐观锁不能解决脏读的问题。**

### 6.Tomcat和Netty

+ Netty和Tomcat最大的区别就在于通信协议，Tomcat是基于Http协议的，他的实质是一个基于http协议的web容器，但是Netty不一样，他能通过编程自定义各种协议，因为netty能够通过codec自己来编码/解码字节流，完成类似redis访问的功能，这就是netty和tomcat最大的不同。

+ 现在高并发分布式网站架构一般采用nginx（前端负载均衡）+ Netty/Tomcat（HTTP）

  Netty是基于Java NIO开发的，而Tomcat是Apache下的针对HTTP的服务器项目，前者更像一个中间件框架，后者更像一个工具

### 7.转账函数怎么写

### 8.有用过消息中间件吗

## 4.7字节飞书一面

### 1.Netty底层如何实现拆包机制

#### 拆包的原理

在没有 Netty 的情况下，用户如果自己需要拆包，基本原理就是不断从 TCP 缓冲区中读取数据，每次读取完都需要判断是否是一个完整的数据包

1. 如果当前读取的数据不足以拼接成一个完整的业务数据包，那就保留该数据，继续从 TCP 缓冲区中读取，直到得到一个完整的数据包。
2. 如果当前读到的数据加上已经读取的数据足够拼接成一个数据包，那就将已经读取的数据拼接上本次读取的数据，构成一个完整的业务数据包传递到业务逻辑，多余的数据仍然保留，以便和下次读到的数据尝试拼接。

如果我们自己实现拆包，这个过程将会非常麻烦，我们的每一种自定义协议，都需要自己实现，还需要考虑各种异常，而 Netty 自带的一些开箱即用的拆包器已经完全满足我们的需求了，下面我们来介绍一下 Netty 有哪些自带的拆包器。

#### Netty 自带的拆包器

+ **1. 固定长度的拆包器 FixedLengthFrameDecoder**

如果你的应用层协议非常简单，每个数据包的长度都是固定的，比如 100，那么只需要把这个拆包器加到 pipeline 中，Netty 会把一个个长度为 100 的数据包 (ByteBuf) 传递到下一个 channelHandler。

+ **2. 行拆包器 LineBasedFrameDecoder**

从字面意思来看，发送端发送数据包的时候，每个数据包之间以换行符作为分隔，接收端通过 LineBasedFrameDecoder 将粘过的 ByteBuf 拆分成一个个完整的应用层数据包。

+ **3. 分隔符拆包器 DelimiterBasedFrameDecoder**

DelimiterBasedFrameDecoder 是行拆包器的通用版本，只不过我们可以自定义分隔符。

+ **4. 基于长度域拆包器 LengthFieldBasedFrameDecoder**

最后一种拆包器是最通用的一种拆包器，只要你的自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包。由于上面三种拆包器比较简单，读者可以自行写出 demo，接下来，我们就结合我们小册的自定义协议，来学习一下如何使用基于长度域的拆包器来拆解我们的数据包。

### 2.Kryo效率为什么好

> **序列化的过程中主要有3个指标：**
>
> 1、对象序列化后的大小
>
> 一个对象会被序列化工具序列化为一串byte数组，这其中包含了对象的field值以及元数据信息，使其可以被反序列化回一个对象
>
> 2、序列化与反序列化的速度
>
> 一个对象被序列化成byte数组的时间取决于它生成/解析byte数组的方法
>
> 3、序列化工具本身的速度
>
> 序列化工具本身创建会有一定的消耗。
> **从序列化后的字节可以看出以下几点**：
>
> 1、Kryo序列化后比Hessian小很多。（kryo优于hessian）
>
> 2、由于Kryo没有将类field的描述信息序列化，所以Kryo需要以自己加载该类的filed。这意味着如果该类没有在kryo中注册，或者该类是第一次被kryo序列化时，kryo需要时间去加载该类（hessian优于kryo）
>
> 3、由于2的原因，如果该类已经被kryo加载过，那么kryo保存了其类的信息，就可以很快的将byte数组填入到类的field中,而hessian则需要解析序列化后的byte数组中的field信息，对于序列化过的类，kryo优于hessian。
>
> 4、hessian使用了固定长度存储int和long，而kryo则使用的变长，实际中，很大的数据不会经常出现。(kryo优于hessian)
>
> 5、hessian将序列化的字段长度写入来确定一段field的结束，而kryo对于String将其最后一位byte+x70用于标识结束（kryo优于hessian）

### 3.数据库对性别sex要不要建索引

> 只有2种取值的字段,建了索引数据库也不一定会用,只会白白增加索引维护的额外开销,因为索引也是需要存储的,所以插入和更新的写入操作,同时需要插入和更新你这个字段的索引的.
>
> 所以说,唯一性太差的字段不需要创建索引,即便用于where条件.
>
> 相关,建立联合索引时,也要考虑把重复率低而又用得多的列放在前面.
> 比如: key (attr_id, attr_value)
> 联合索引左匹配:单查 attr_id 也能使用索引,单查 attr_value 将无法利用该联合索引.

### 4.联合索引底层（最左匹配）

> **最左前缀匹配原则：**在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
>
> 要想理解联合索引的最左匹配原则，先来理解下索引的底层原理。索引的底层是一颗B+树，那么联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。

### 5.堆和栈为什么不能合并

> 因为结构化语言里函数（子程序）调用最方便的实现方式就是用栈，以至于现在绝大部分芯片都对栈提供芯片级的硬件支持，一条指令即可搞定栈的pop操作。栈的好处是：方便、快、有效避免内存碎片化。栈的问题是：不利于管理大内存（尤其在16位和32位时代）、数据的生命周期难于控制（栈内的有效数据通常是连续存储的，所以pop时后申请的内存必须早于先申请的内存失效），所以栈不利于动态地管理并且有效地利用宝贵的内存资源。于是我们有了堆

### 6.TCP唯一标识

> TCP/IP唯一性含除**地址**和**端口（源端口和目的端口）**外还有一个时间上的标记才可完全确立。
> 对TCP而言在三次握手时的SYN标志会使用上一个**ISN**值，这个值是使用32位计数器，由0-4294967295，每一次连接都会分配到一个ISN值，连接双方对这个值会记录共识，假如这个值不一，就说明了这个连接已超时或无效甚至是被人恶意攻击冒充连接。

### 7.Zookeeper集群

![image-20210408233735887](C:\Users\95845\AppData\Roaming\Typora\typora-user-images\image-20210408233735887.png)

### 8.限流熔断

常见的限流算法：固定窗口计数器算法、滑动窗口计数器算法、漏桶算法、令牌桶算法

### 9.浏览器输入 URL 发生了什么

主要包括以下几个基本步骤：

1. 浏览器的地址栏输入URL并按下回车。
2. 浏览器查找当前URL是否存在缓存，并比较缓存是否过期。
3. DNS解析URL对应的IP。
4. 根据IP建立TCP连接（三次握手）。
5. HTTP发起请求。
6. 服务器处理请求，浏览器接收HTTP响应。
7. 渲染页面，构建DOM树。
8. 关闭TCP连接（四次挥手）。

### 10.四次挥手TIME_WAIT中2MSL

RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。

因此2MSL实际值应为4分钟

## 4.12飞书二面

### 1.Java I/O模型（os）

### 2.10w个数据怎么排序

### 3.外排序

## 4.12腾讯一面

### 1.TCP如何实现可靠传输

### 2.epoll在netty中的使用

### 3.IP数据报的校验和相较于TCP（UDP）报文校验和有什么区别

> UDP首先提供了校验和的功能，（以太网等协议也提供了差错控制）**其原因是不能保证源和目的之间的所有链路都提供差错检测。**这就是说，也许这些链路中的一条可能使用没有差错检测的协议。此外，即使报文段经链路正确地传输，当报文段存储在某台路由器的内存中时，也可能引入比特差错。
>
> **在既无法确保链路可靠性，又无法确保内存中的差错检测的情况下。**UDP就必须在**端到端**的基础上在运输层提供差错检测。这是一个在系统设计中被称颂的**端到端原则**的例子

## 4.13携程二面

### 1.反射有什么好处

+ **获取Class对象的三种方式**

1. Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象多用于配置文件，将类名定义在配置文件中。读取文件，加载类，如JDBC等。
2. 类名.class：通过类名的属性class获取多用于参数的传递。
3. 对象.getClass()：getClass()方法在Object类中定义着。多用于对象的获取字节码的方式。

**反射好处：**

反射、泛型创建对象主要用于解耦

## 2.Zookeeper的选举机制

## 3.Zookeeper服务器间通信

## 4.19招行卡中心一面

### 1.InvocationalHandler底层

不知道

### 2.分布式CAP理论

## 4.22蚂蚁一面

### 1.RPC框架中两个服务会注册两次吗

涉及负载均衡知识。

![g](C:\Users\95845\AppData\Roaming\Typora\typora-user-images\image-20210422154232573.png)

### 2.操作系统如何管理TCP/IP

### 3.JDK动态代理和cglib动态代理

1、JDK动态代理具体实现原理：

通过实现InvocationHandler接口创建自己的调用处理器；
通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理；
通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型；
通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入；
JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力，Spring通过Java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。

2、CGLib动态代理：

利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。

> 我们了解到，“代理”的目的是构造一个和被代理的对象有同样行为的对象，一个对象的行为是在类中定义的，对象只是类的实例。所以构造代理，不一定非得通过持有、包装对象这一种方式。
>
> 通过“继承”可以继承父类所有的公开方法，然后可以重写这些方法，在重写时对这些方法增强，这就是cglib的思想。根据里氏代换原则（LSP），父类需要出现的地方，子类可以出现，所以cglib实现的代理也是可以被正常使用的。

3、两者对比：

JDK动态代理是面向接口的。
CGLib动态代理是通过字节码底层继承要代理类来实现，因此如果被代理类被final关键字所修饰，会失败

### 4.线程池中工作队列需要注意什么

不能使用无界队列，要设定合适的容量大小，不然会发生队列溢出，OOM

**任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。**

### 5.讲讲Selector类实现机制

### 6.Netty通信中如果服务器宕机是怎么做的

在client模块做的超时策略

![image-20210422155504248](C:\Users\95845\AppData\Roaming\Typora\typora-user-images\image-20210422155504248.png)

![image-20210422155119386](C:\Users\95845\AppData\Roaming\Typora\typora-user-images\image-20210422155119386.png)

### 7.Netty框架如何使用TCP/IP

Netty中的tcp/ip体现

客户端采用bootstrap.connect()方法异步进行连接

![image-20210422155817547](C:\Users\95845\AppData\Roaming\Typora\typora-user-images\image-20210422155817547.png)

## 4.22美团点评一面

### 1.Spring Bean对象的初始化

### 2.输入url后加载网页的过程

　　1、浏览器的地址栏输入URL并按下回车。

　　2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。

　　3、DNS解析URL对应的IP。

　　4、根据IP建立TCP连接（三次握手）。

　　5、HTTP发起请求。

　　6、服务器处理请求，浏览器接收HTTP响应。

　　7、渲染页面，构建DOM树。

　　8、关闭TCP连接（四次挥手）。

## 7.20 字节Data一面

### Collections类

#### ArrayList与LinkedList的插入效率

ArrayList插入效率要考虑插入索引位置，如果ArrayList为空则直接插末尾为O（1），否则根据索引i位置 复杂度：O（n-i）

LinkedList插入效率为O（1）

### LC23 合并K个升序链表

### JVM

1、方法区能不能垃圾回收

2、静态方法究竟是在方法区中还是字节码文件内？

3、静态成员变量创建的对象在堆中还是方法区？

### 单例模式

1、volatie的用处？（内存屏障性和防止指令重排）

2、方法上static的作用？（不用static的话创建不了实例，因为构造方法私有）

## 字节抖音社交

字节一面7.9
因为还要准备期末考试，所以字节的面试战线有点长

自我介绍
Http和Https区别
什么是线程安全问题？怎么解决？
乐观锁悲观锁介绍一下
AQS相关
线程争抢资源的能力是什么？（自己答AQS的CLH队列的时候给自己挖的坑=，=
链表查找时间复杂度？怎么优化？
跳表实现说一下？时空复杂度？
设计题：如何准备飞机上的面与饭的数量？（第一次见这种题，直接放飞自我QAQ
最后一道算法lc79. 单词搜索

字节二面7.13
自我介绍
OS学过吗？
线程和进程区别？为什么还要提出线程这个概念？线程共享了什么？协程呢？线程真的比进程节约资源吗？（一套组合拳把我问傻
LRU了解吗？说一下实现思路？（lc经典题了，说了个map+双向链表的实现
那这个map你能手写出来吗？（经过百度二面后我也是又恶补了hashmap的实现，刷了几道lc相关的题
hash冲突怎么处理？除了拉链法你还知道哪些？
并发resize怎么实现？这时候来了读写操作呢？说一下具体流程？（我说了concurrentHashMap的实现思路
concurrentHashMap你能实现出来吗？（我何德何能啊=，=
最后一道经典算法，lc25. K个一组翻转链表
这场面试发现了自己很多不足，收获很大！

字节三面7.16，已oc
这场项目问的比较多

自我介绍
项目中分布式事务是怎么实现的？
能详细说说seata和RocketMQ的事务消息是怎么实现的吗？
如何保证消息顺利投放到MQ中？投放前宕机了怎么办？
详细说一下你们项目中的秒杀业务流程？
项目中的限流是怎么做的？
限流算法了解哪些？
设计题：用令牌桶算法设计一个限流器？（经过面试官的引导好歹是写出来了=，=
最后一道算法：经典lc46. 全排列

## 京东一面

1、线程池八个参数

2、JVM如何加载Class文件，过程

3、AQS底层

4、InnoDB的索引结构好处

## 7.30 米哈游一面

1、格斗等低延时动作，应该用tcp还是udp
  如果不能接受100ms左右的延时，考虑使用udp

2、Redis的事务

3、IO多路复用中，什么场景会使用select？

> 例如：一个游戏服务器，tcp server负责接收客户端的连接，dbserver负责处理数据信息，一个webserver负责处理服务器的web请求，gameserver负责游戏的逻辑处理，所有这些服务都和另外一个gateserver相连，gateserver负责服务器间的通信和转发（进程间通信）。
>
> 只要游戏服务器在服务状态，这些连接几乎不会断开（异常情况可能会断开），并且这些连接数量一般不会很多。这种情况，select还是epoll呢？很明显是select，因为每时每刻这些连接的socket都有事件发生（比如：服务期间的心跳信息，还有大型网络游戏的同步信息（一般每秒在20-30次）），最重要的是，这种场景下，并发量也不会很大。如果此时用epoll，为此所建立的文件系统，红黑书和链表对于此来说就是杀鸡用牛刀，效率反而不高。
>
> 当然这里的tcp server负责大量的客户端的连接，毫无疑问epoll是首选，它接受大量的客户端连接，收到客户端的消息之后把消息转发发给select网络模型的gateserver，gateserver再转发给gameserver进行逻辑处理，最后返回给客户端就over了。因此在如果在并发量低，socket都比较活跃的情况下，select就不见得比epoll慢了(就像我们常常说快排比插入排序快，但是在特定情况下这并不成立)。

4、epoll两种工作模式LT和ET
  LT：水平触发，只要文件描述符还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作。

  ET：边缘触发，检测到有IO事件时，通过epoll_wait调用会得到有事件通知的文件描述符，对于每一个被通知的文件描述符，必须将该文件描述符一直读到空，让errno返回EAGAIN为止，否则下次的epoll_wait不会返回余下的数据，会丢掉事件。

  ET比LT更加高效，因为ET只通知一次，而LT会通知多次，LT可能会充斥大量不关心的就绪文件描述符。

5、MySQL的myisam和Innodb的区别，以及各自的应用场景

6、TCP的拥塞控制机制以及Nagle算法
  答：Nagle就是小于MSS（1460bytes）的报文会存到下一次发送，然后默认200ms超时会自动发送。

7、Redis的多线程？Redis的事务？

8、RDB会阻塞主线程吗？如果AOF文件量很大该怎么办？

9、Redis读写性能高的原因

  1. 基于Hash存储
  2. Redis数据结构简单，有些数据结构是专门设计的
  3. Reactor-IO多路复用模型

10、关于Linux

  10.1、查看整体状态操作？

  10.2、僵尸进程和孤儿进程的区别？kill的原理？

11、MySQL慢查询及如何定位问题

## 7.30 京东二面

1、设计题：10亿的url去重
